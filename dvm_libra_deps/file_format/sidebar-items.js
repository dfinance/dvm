initSidebarItems({"constant":[["ACQUIRES_COUNT_MAX",""],["ADDRESS_INDEX_MAX",""],["BINARY_SIZE_LIMIT","Upper limit on the binary size"],["BYTECODE_COUNT_MAX",""],["BYTECODE_INDEX_MAX",""],["CONSTANT_INDEX_MAX",""],["CONSTANT_SIZE_MAX",""],["FIELD_COUNT_MAX",""],["FIELD_HANDLE_INDEX_MAX",""],["FIELD_INST_INDEX_MAX",""],["FIELD_OFFSET_MAX",""],["FUNCTION_HANDLE_INDEX_MAX",""],["FUNCTION_INST_INDEX_MAX",""],["IDENTIFIER_INDEX_MAX",""],["IDENTIFIER_SIZE_MAX",""],["LOCAL_INDEX_MAX",""],["MODULE_HANDLE_INDEX_MAX",""],["NO_TYPE_ARGUMENTS","Index 0 into the LocalsSignaturePool, which is guaranteed to be an empty list. Used to represent function/struct instantiation with no type arguments – effectively non-generic functions and structs."],["NUMBER_OF_NATIVE_FUNCTIONS",""],["SIGNATURE_INDEX_MAX",""],["SIGNATURE_SIZE_MAX",""],["SIGNATURE_TOKEN_DEPTH_MAX",""],["STRUCT_DEF_INDEX_MAX",""],["STRUCT_DEF_INST_INDEX_MAX",""],["STRUCT_HANDLE_INDEX_MAX",""],["TABLE_CONTENT_SIZE_MAX",""],["TABLE_COUNT_MAX",""],["TABLE_INDEX_MAX",""],["TABLE_OFFSET_MAX",""],["TABLE_SIZE_MAX",""],["TYPE_PARAMETER_COUNT_MAX",""],["TYPE_PARAMETER_INDEX_MAX",""]],"enum":[["BinaryConstants","Constant values for the binary format header."],["Bytecode","`Bytecode` is a VM instruction of variable size. The type of the bytecode (opcode) defines the size of the bytecode."],["Kind","A `Kind` classifies types into sets with rules each set must follow."],["Opcodes","List of opcodes constants."],["SerializedKind",""],["SerializedNativeStructFlag",""],["SerializedNominalResourceFlag",""],["SerializedType","Constants for signature blob values."],["SignatureToken","A `SignatureToken` is a type declaration for a location."],["StructFieldInformation","`StructFieldInformation` indicates whether a struct is native or has user-specified fields"],["TableType","Constants for table types in the binary."]],"fn":[["basic_test_module","Create the following module which is convenient in tests: // module  { //     struct Bar { x: u64 } // //     foo() { //     } // }"],["dummy_procedure_module","Create a dummy module to wrap the bytecode program in local@code"],["empty_module","Return the simplest module that will pass the bounds checker"],["empty_script","Return a simple script that contains only a return in the main()"],["instruction_key","The encoding of the instruction is the serialized form of it, but disregarding the serialization of the instruction’s argument(s)."],["read_u32",""],["read_u8",""],["read_uleb128_as_u64",""],["self_module_name",""],["write_u64_as_uleb128",""]],"struct":[["AddressIdentifierIndex","Index into the `AddressIdentifier` table."],["BinaryData","A wrapper for the binary vector"],["CodeUnit","A `CodeUnit` is the body of a function. It has the function header and the instruction stream."],["CompiledModule","A `CompiledModule` defines the structure of a module which is the unit of published code."],["CompiledModuleMut","A mutable version of `CompiledModule`. Converting to a `CompiledModule` requires this to pass the bounds checker."],["CompiledScript","Contains the main function to execute and its dependencies."],["CompiledScriptMut","A mutable version of `CompiledScript`. Converting to a `CompiledScript` requires this to pass the bounds checker."],["Constant","A `Constant` is a serialized value along with it’s type. That type will be deserialized by the loader/evauluator"],["ConstantPoolIndex","Index into the `ConstantPool` table."],["FieldDefinition","A `FieldDefinition` is the definition of a field: its name and the field type."],["FieldHandle","A field access info (owner type and offset)"],["FieldHandleIndex","Index into the `FieldHandle` table."],["FieldInstantiation","A complete or partial instantiation of a field (or the type of it)."],["FieldInstantiationIndex","Index into the `FieldInstantiation` table."],["FunctionDefinition","A `FunctionDefinition` is the implementation of a function. It defines the prototype of the function and the function body."],["FunctionDefinitionIndex","Index into the `FunctionDefinition` table."],["FunctionHandle","A `FunctionHandle` is a reference to a function. It is composed by a `ModuleHandle` and the name and signature of that function within the module."],["FunctionHandleIndex","Index into the `FunctionHandle` table."],["FunctionInstantiation","A complete or partial instantiation of a function"],["FunctionInstantiationIndex","Index into the `FunctionInstantiation` table."],["FunctionSignature","A `FunctionSignature` in internally used to create a unique representation of the overall signature as need. Consider deprecated…"],["IdentifierIndex","Index into the `Identifier` table."],["ModuleHandle","A `ModuleHandle` is a reference to a MOVE module. It is composed by an `address` and a `name`."],["ModuleHandleIndex","Index into the `ModuleHandle` table."],["ScriptConversionInfo",""],["Signature","A `Signature` is the list of locals used by a function."],["SignatureIndex","Index into the `Signature` table."],["SignatureTokenPreorderTraversalIter","An iterator to help traverse the `SignatureToken` in a non-recursive fashion to avoid overflowing the stack."],["SignatureTokenPreorderTraversalIterWithDepth","Alternative preorder traversal iterator for SignatureToken that also returns the depth at each node."],["StructDefInstantiation","A complete or partial instantiation of a generic struct"],["StructDefInstantiationIndex","Index into the `StructInstantiation` table."],["StructDefinition","A `StructDefinition` is a type definition. It either indicates it is native or"],["StructDefinitionIndex","Index into the `StructDefinition` table."],["StructHandle","A `StructHandle` is a reference to a user defined type. It is composed by a `ModuleHandle` and the name of the type within that module."],["StructHandleIndex","Index into the `StructHandle` table."],["TypeSignature","A type definition. `SignatureToken` allows the definition of the set of known types and their composition."]],"trait":[["ModuleAccess","Represents accessors for a compiled module."]],"type":[["AddressIdentifierPool","The pool of address identifiers (addresses used in ModuleHandles/ModuleIds). Does not include runtime values. Those are placed in the `ConstantPool`"],["CodeOffset","Index into the code stream for a jump. The offset is relative to the beginning of the instruction stream."],["ConstantPool","The pool of `Constant` values"],["IdentifierPool","The pool of identifiers."],["LocalIndex","Index of a local variable in a function."],["MemberCount","Max number of fields in a `StructDefinition`."],["SignaturePool","The pool of `Signature` instances. Every function definition must define the set of locals used and their types."],["TableIndex","Generic index into one of the tables in the binary format."],["TypeParameterIndex","Type parameters are encoded as indices. This index can also be used to lookup the kind of a type parameter in the `FunctionHandle` and `StructHandle`."],["TypeSignaturePool","The pool of `TypeSignature` instances. Those are system and user types used and their composition (e.g. &U64)."]]});