syntax = "proto3";

package vm;

// Type of contract (module or script).
enum ContractType {
    Module = 0; // If VM works with module.
    Script = 1; // If VM works with script.
}

// Status of contract execution.
enum ContractStatus {
    Discard = 0; // If transaction should be ignored, because of error.
    Keep = 1; // If we keep transaction and write write_set.
}

// Status of code contract execution.
message VMErrorStatus {
    uint64 major_status = 1; // Major error status.
    uint64 sub_status = 2; // Sub status if needed (optional).
    string message = 3; // Message with error details if needed (optional).
}

// Type of value returned by event during contract execution.
enum VMTypeTag {
    Bool = 0;  // Bool
    U64  = 1;  // Uint64
    ByteArray = 2; // Bytes
    Address   = 3; // Address
    Struct    = 4; // Structure (could be several arguments for event call).
}

// Describing VMType for events.
message VMType {
    VMTypeTag tag = 1; // Type.
    StructTag struct_tag = 2; // If type is Struct put struct into variable, otherwise not, optional value.
}

// Structure tag (for vm events contains structures).
message StructTag {
    bytes  address = 1; // address of module owner
    string module = 2; // module where event happens.
    string name = 3; // name of event (not sure yet, need to test).
    VMType type_params = 4; // event parameters (recursive).
}

// VM event returns after contract execution.
message VMEvent {
    bytes key = 1; // key to store vm event.
    uint64 sequence_number = 2; // sequence number of event during execution.
    VMType type = 3; // Type of value inside event.
    bytes event_data = 4; // Event data in bytes to parse.
}

// VM value should be passed before execution and return after execution (with opcodes), write_set in nutshell.
message VMValue {
    bytes value = 1; // Value returns from vm.
    string type = 2; // Type of value
    string key = 3; // Key to store value.
}

// VM contract object to process.
message VMContract {
    bytes address = 1; // owner of contract (module) or script executor.
    bytes code = 2; // compiled contract code.
    bytes name = 3; // name of module (if contract is module).
}

//
// Requests
//

// Response from VM contains write_set, events, gas used and status for specific contract.
message VMExecuteResponse {
    map<string, VMValue> write_set = 1; // using string instead of bytes for now, as map support only ints and strings as keys
    repeated VMEvent events = 2; // list of events executed during contract execution
    uint64 gas_used = 3; // Gas used during execution.
    ContractStatus status = 4; // Status of contract execution.
    VMErrorStatus statusStruct = 5; // Status in case of error.
}

// Response from VM in case of execution multiplay contracts.
message VMExecuteResponses {
    repeated VMExecuteResponse executions = 1; // Result of executions.
}

// Request to get values from VM
message VMValuesRequest {
    repeated VMContract contracts = 1; // Array of contracts to extract needed values.
    map<string, VMContract> imports = 2; // Related contracts (imports).
    uint64 option = 3; // Configurable mode of command execution.
}

// Contains collected keys needed by contracts inside VMValuesRequest.
message VMValuesResponse {
    repeated string keys = 1; // Keys of required values by contract.
    uint64 gas_used = 2; // Gas used by keys extraction operation.
}

// Contains responses of values used in contracts in case of multiplay contracts.
message VMValuesResponses {
    repeated VMValuesResponse values = 1; // Values responses.
}

// Request to VM to extract all imports from code.
message VMImportsRequest {
    repeated VMContract contracts = 1; // Contracts to extract imports.
}

// Response from VM with extracted imports from contract.
message VMImportsResponse {
    repeated string keys = 1; // Keys of imports (modules).
    uint64 gas_used = 2; // Gas used during extract operations.
}

// Responses from VM with extracted imports in case of multiplay contracts.
message VMImportsResponses {
    repeated VMImportsResponse imports = 1; // Array of imports.
}

// Execute request for VM
message VMExecuteRequest {
    repeated VMContract contracts = 1; //
    map<string, VMContract> imports = 2; // contracts that will be import during execution (if need)
    map<string, VMValue> values = 3; // values will be used during execution of contract
    uint64 options = 4; // options to execute.
}

// GRPC service
service VMService {
    rpc ExecuteContracts (VMExecuteRequest) returns (VMExecuteResponses) {}
    rpc GetImports(VMImportsRequest) returns (VMImportsResponses) {}
    rpc GetValues(VMValuesRequest) returns (VMValuesResponses) {}
}
